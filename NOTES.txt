///////////////////////////////////////////////////////////////////////////////
// This document contains course notes for the course:
// "C++ Game Engine Programming" by Gustavo Pezzi
// https://pikuma.com/courses/cpp-2d-game-engine-development
///////////////////////////////////////////////////////////////////////////////

 SECTIONS:
   #1: COURSE OVERVIEW
   #2: C++
   #3: OTHER NOTES
   #4: LINKS AND RESOURCES

///////////////////////////////////////////////////////////////////////////////
// #1 | COURSE OVERVIEW:
///////////////////////////////////////////////////////////////////////////////

   [X]  #1: Introduction
   [X]  #2: Libraries & Dependencies
   [X]  #3: Displaying the Game Window
   [X]  #4: Rendering SDL Objects
   [X]  #5: Fixing the Game Time Step
   [X]  #6: Logger
   [-]  #7: Files & Folder Structure
   [-]  #8: Organizing Game Objects
   [-]  #9: ECS Design
   [-] #10: ECS Implementation
   [-] #11: Creating Entities & Components
   [-] #12: Creating Systems
   [-] #13: Managing Assets
   [-] #14: Animation System
   [-] #15: Collision System
   [-] #16: Killing Entities
   [-] #17: Event System
   [-] #18: Other Useful Components & Systems
   [-] #19: Tagging & Grouping Entities
   [-] #20: Data-Oriented Design
   [-] #21: Displaying True-Type Fonts
   [-] #22: Dear ImGui
   [-] #23: Culling & Map Control
   [-] #24: Lua Scripting
   [-] #25: Next Steps
   [-] #26: Bonus: The Map Editor
   [-] #27: Moving Forward
  
   [X] COMPLETED / [-] NOT COMPLETED


///////////////////////////////////////////////////////////////////////////////
// #2 | C++
///////////////////////////////////////////////////////////////////////////////

 - Compiling:
     C++ Source Code 
          -> 
     Preprocessor
       Scans source code, checks for hashtag statements (#include, #define, etc)
          -> 
     Compiler
       Checks if everything makes sense, obeys the rules of C++ syntax, 
       name of functions, order of parameters, etc.
          -> 
     Linker
       Bundling everything together, link all the implementations of
       the libraries together
          ->
     Executable

 - External libraries can be included in two ways:
     1 - Source code of the library:
          The source code of the libraries need to be placed in the project
          folder (e.g. in a "libs" folder) and included in the C++ file using
          #include <(library name)/(header file).hpp> and the compiler command 
          -I"./libs" is used to include the source code folder when compiling.
     2 - Pre-compiled binaries (faster than compiling on each build):
           The libraries (for this project SDL2 and Lua are pre-compiled) need
           to be installed on the system, included in the C++ file by using 
           #include <(library name)/(header file).hpp> and linked in the
           compiler by using -l(library name) in the command when compiling.
 
 - This project will use modern C++ with the C++17 standard.

 - The project will use the following libraries:
     SDL2:       (pre-compiled) rendering and input
     GLM:        (source code)  math helper
     Dear ImGui: (source code)  to create UI
     Sol:        (source code)  binding for modern C+++ & Lua

 - Command to compile the project using the GNU compiler (simple example):
     g++ -Wall -std=c++17 src/Main.cpp -lSDL2 -o gameengine
      |     |       |            |        |          |      
      |     |       |            |        |    Output executable file
      |     |       |            |     Linked library 
      |     |       |   Included C++ files for the project
      |     |   C++ standard
      | Show errors
  The compiler

 - To make things easier compiling rules will be written in the Makefile.
     "build" for building the project
     "clean" to delete compiled files
     "run" to run the project
     (To build the project simply run the "make build" command)

 - The C++ file is divided into two files.
   Header file (.h) and Implementation File (.cpp).
   The header file only contain the function prototypes (name of the function,
   return value and parameters) and no implementation. 
   Similar to the "table of contents" section in a book.
   Implementation files (.cpp) contain the body of the function defined in the
   header file.

 - Header protection guard:
     Makes sure a header file is only included once.
     Always remember to include a protection guard in header files.
       #ifndef (name)
       #define (name)
       ...
       #endif
     Or:
       #pragma once

 - This project will use the ECS (Entity component system) programming pattern

 - When making an object the contructor is invoked and the destructor is
   invoked when the object is destroyed.
   If making a new object without using the "new" keyword the object will be 
   stored in the stack and be detroyed when the scope ends.

 - SDL is using double-buffered rendering:
   One buffer is displayed on screen while the other buffer is prepared
   and swapped when it's ready to be presented.
 
 - For this project we'll make our own simple Logger class for logging,
   but for something to use in real life production a third party library might
   be a better option with scalability and performance in mind.

 - Popular logging libraries:
    + SPDLog library (for C++ projects) here: https://github.com/gabime/spdlog
    + Log.c library (for C99 projects) here: https://github.com/rxi/log.c

 - Object-oriented programming and the stack:
    + The stack is a place in memory where we can push values and pop values.
    + ExampleClass example // Creating an object in the stack (without the "new" 
      keyword), it will automatically be destroyed when the scope ends.
    + In the stack, the allocation happens on contigous blocks of memory.
      It can grow and shrink when we push and pop values.
    + The size of memory to be allocated is know to the compiler.
    + The stack has a fixed size (OS-dependent (Linux gives 2MB per thread by
      default))
    + We don't have to worry about memory allocation/dealloation of 
      stack variables

 - Object-oriented programming and the heap:
    + The heap is also memory, we can allocate more and more memory as needed
    + In the heap we are responsible for deallocating the memory when
      we don't need it any more. If we forget to do this we get memory leaks!
    + ExampleClass* example = new ExampleClass(); // Creates an object in the
      heap using the "new" keyword. It needs to be explicitly deleted.
    + delete example // deletes the object deallocates the memory
    + In the heap, memory is allocated dynamically and it's usually
      not contigous
    + The heap has no fixed-size restrictions, but heap handling is slower
      than stack handling
    + The programmer is responsible for remembering to deallocate the object
      in memory
    + The "new" keyword replaces how it was done previously in C with
      memory allocation (malloc) and Initialization (constructor).
      The "new" keyword allocates memory and calls the constructor.
    + the "delete" keyword replaces how it was done previously in C with
      Deinitialization (destructor) and Deallocation (free).
      The "delete" keyword calls the destructor and deallocates memory.

 - Examples of C++ Object Creation:
    
    + We create a single Enemy object in the stack and we don't need to 
      explicitly delete the object since it will be destroyed automatically 
      once we leave the scope of the function block:

      class Enemy {
          public:
              Enemy()  { /* Constructor */ }
              ~Enemy() { /* Destructor */ }
              
              ...
              ...
              ...
      };

      void Run() {
          Enemy e;

          // Here we can use the object
      }
    
    + We create a single Bullet object dunamically in the heap and call its
      constructor by using the new keyword, and we also need to explicitly
      call delete to destroy and free the object:

      class Bullet {
          public:
              Bullet()  { /* Constructor */}
              ~Bullet() { /* Destructor */}

              ...
              ...
              ...
      };

      void Run(){
          Bullet* b = new Bullet;

          // Here we can use the object

          delete b;
      }

    + We create a static array of 100 Particle objects dynamically and invoke
      their constructors by using new[100]. We also need to explicitly call
      delete[] to destroy all the objects in the array:

      class Particle {
          public:
              Particle()  { /* Constructor */}
              ~Particle() { /* Destructor */}

              ...
              ...
              ...
      };

      void Run(){
          Particle* p = new Particle[100];

          // Here we can use the array

          delete[] p;
      }

    + Note: These examples use raw pointers to deal with C++ objects.
      Modern C++ uses smart pointers to help programmers with the issue of
      having to remember to manually destroy objects and in this project we
      will use smart pointers.

 - Organizing Game Objects:
    + Game programming is a good sandbox to learn and practice the ideas of
      object-oriented programming (OOP).
    + In games there are a lot of things: Items, characters, bullets, etc.
      This can go under different names in different game engines:
      "Actors", "GameObject" (Unity), etc.
      For our project we will name it Entity.

 - Object Inheritance Design:

    + At first glance it might seem like a good approach, but it is in fact
      not super perfect.

                           Thing
             ("game object", "actor", "entity")
       Everything inherits from the base parent class.
              /        |          |         \
             /         |          |          \
          Player     Enemy     Obstacle     Light

    + Most game engines do NOT use the inheritance approach.
      Because the different types of entities might be very different
      and have few similarities to use in the base class.
      Multiple inheritance issue in C++ (diamond inheritance).

 - Component-Based Design:
    + ...

///////////////////////////////////////////////////////////////////////////////
// #3 | OTHER NOTES
///////////////////////////////////////////////////////////////////////////////

 - Game loop: Process input -> Update Game -> Render (the holy trinity)

 - The game loop needs to be steady capped at a desired FPS with a 
   fixed time step. We can use SDL_Delay() to achieve this.

 - All position/physics updates need to take into account how much time has
   passed since last frame and multiply the movement by this factor to achieve
   the same results on different framerates. This is called Delta-Time.

 - There are two types of Delta-Time:
   Variable Delta-Time:
    + Con: Non-deterministic
    + Pro: Game time equals real time
   Constant Delta-Time:
    + Con: Fast game on high FPS, slow game on low FPS
    + Pro: Deterministic
   For this project we will start by implementing a simple Variable Delta-Time.

 - There are smarter and fancier ways to implement a controlled time step:
     "Fix Your Timestep!" by Glenn Fiedler
     https://gafferongames.com/post/fix_your_timestep/


///////////////////////////////////////////////////////////////////////////////
// #4 | LINKS AND RESOURCES
///////////////////////////////////////////////////////////////////////////////

 - ...


